const cluster = require("cluster");
const webpack = require('webpack');
const configs = require("../webpack.config")(null, { watch: false, includeProductInfo: true }).map((config, index) => {
    const { product } = config;
    delete config.product; 
    return ({ 
        ID: index, 
        config,
        product
     })
});
class MessagesFactory {
    static create(type, payload) {
        const types = ['task-finish', 'task', 'exit'];

        if(!types.includes(type)) {
            throw new Error("Unknown Message Type");
        }

        return {
            type,
            payload
        };
    }
}

class buildState {
    constructor() {
        this.failedProjects = [];
    }
    onBuildFailed(project, error) {
        this.failedProjects.push(project);
    }

    displayBuildReport() {
        console.clear();
        if(this.failedProjects.length === 0) {
            console.log("All Products Build Successfully");
        } else {
            console.log("Build Failed For Some Products \n");
            console.log(JSON.stringify(this.failedProjects));
        }
    }
}

class ParallelBuildController {

    constructor(buildStatusTracker) {
        this.tracker = buildStatusTracker;
     }

    initialize() {
        if(cluster.isMaster) {
            this.initiateAsMain();
        } else {
            this.initiateAsProcess();
        }
    }

    initiateAsProcess() {
        this.subscribe("message", (message) => {
            switch(message.type) {
                case 'task':
                    this.initBuild(message.payload.ID);
                    break;
                case 'exit':
                    process.exit(0);
                    break;
            }
        });
    }

    initiateAsMain() {
        this.configsQueue = (configs || []).map(config => ({...config, started: false, finished: false  }));
        console.log(configs.length, "number");
        const numCores = require('os').cpus().length;
        this.startChildProcess(numCores);
        this.subscribe("online", (worker) => {
            try {
                this.AssignTaskToProcess(worker);
            } catch {
                this.checkQueueStatusAndTerminate();
            }
        });

        this.subscribe("message", (worker, message) => {
            if(message.type !== 'task-finish')
                return;
            const config = this.configsQueue.find(item => item.ID === message.payload.ID);
            if(message.payload.status !== 0) {
                this.tracker.onBuildFailed(config.product);
            }
            config.finished = true;
            try {
                this.AssignTaskToProcess(worker);
            } catch {
                this.checkQueueStatusAndTerminate();
            }
        })
    }

    startChildProcess(numberOfProcess) {
        for(let i = 0; i < numberOfProcess; i++) 
            cluster.fork();
    }

    AssignTaskToProcess(worker) {
        const newTask = this.configsQueue.find(item => !item.started);
        if(newTask){
            newTask.started = true;
            worker.send(MessagesFactory.create("task", { ID: newTask.ID }));
        } else {
            throw new Error("no task found");
        }
    }

    checkQueueStatusAndTerminate() {
        const isProgress = this.configsQueue.find(item => item.started && !item.finished);
        if(!isProgress) 
        this.terminate();
    }

    initBuild(ID) {
        const config = configs.find(config => config.ID === ID).config;
        config.stats = 'none';
        try {
            const compiler = webpack(config);
            new webpack.ProgressPlugin((percentage, message) => {}).apply(compiler);
            compiler.run((err, stats) => { 
                let status = 0;
                if (err || stats.hasErrors()) {
                    status = 1;
                }
                process.send(MessagesFactory.create('task-finish', { status,  ID }));
            });
        } catch(e) {
            console.log(e)
        }
    }
    
    subscribe(event, handler) {
        if(cluster.isMaster) {
            cluster.on(event, handler);
        } else {
            process.on(event, handler);
        }
    }

    async terminate() {
        for (const id in cluster.workers) {
            cluster.workers[id].send(MessagesFactory.create('exit'));
        }
        this.tracker.displayBuildReport();
        process.exit(0);

    }


}

const buildContoller = new ParallelBuildController(new buildState());
buildContoller.initialize();